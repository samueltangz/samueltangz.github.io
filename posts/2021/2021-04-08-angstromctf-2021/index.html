<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>ångstromCTF 2021: Cache Money :: Mystify</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="I played ångstromCTF 2021 for @blackb6a to spend my Easter holiday. I solved most of the reverse and cryptography challenges alone. In particular, Cache Money is one of the harder crypto challenges that I spent more than one day dealing with. It is very rewarding, and eventually four teams ended up solving it.
Challenge Summary This challenge reimplements the Advanced Encryption Standard (AES) on 128, 192 and 256-bit keys. The encryptor is equipped with caches and we are given a service to encrypt (or decrypt) our messages." />
<meta name="keywords" content="ctf" />
<meta name="robots" content="noodp" />
<link rel="canonical" href="https://mystiz.hk/posts/2021/2021-04-08-angstromctf-2021/" />




<link rel="stylesheet" href="https://mystiz.hk/assets/style.css">

  <link rel="stylesheet" href="https://mystiz.hk/assets/mystiz.css">






<link rel="apple-touch-icon" href="https://mystiz.hk/img/apple-touch-icon-192x192.png">

  <link rel="shortcut icon" href="https://mystiz.hk/img/favicon/mystiz.png">





<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://mystiz.hk/images/2021-04-08-angstromctf/cache-money.png" />


  
    <meta name="twitter:site" content="" />
  
    <meta name="twitter:creator" content="mystiz613" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="ångstromCTF 2021: Cache Money">
<meta property="og:description" content="I played ångstromCTF 2021 for @blackb6a to spend my Easter holiday. I solved most of the reverse and cryptography challenges alone. In particular, Cache Money is one of the harder crypto challenges that I spent more than one day dealing with. It is very rewarding, and eventually four teams ended up solving it.

This challenge reimplements the Advanced Encryption Standard (AES) on 128, 192 and 256-bit keys. The encryptor is equipped with caches and we are given a service to encrypt (or decrypt) our messages. In short, there are four oracles provided by the service ($k_0$ is the fixed secret key and $b \in \\{128, 192, 256\\}$)." />
<meta property="og:url" content="https://mystiz.hk/posts/2021/2021-04-08-angstromctf-2021/" />
<meta property="og:site_name" content="Mystify" />

  <meta property="og:image" content="https://mystiz.hk/images/2021-04-08-angstromctf/cache-money.png">

<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">


  <meta property="article:published_time" content="2021-04-08 08:00:00 &#43;0800 &#43;0800" />












  <script data-ad-client="ca-pub-3220069814773012" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>


</head>
<body class="mystiz">


<div class="container center headings--one-size">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    Mystify
  </div>
</a>

    </div>
    <div class="menu-trigger">menu</div>
  </div>
  
    <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/about-me">About Me</a></li>
        
      
        
          <li><a href="/blogroll">Blogroll</a></li>
        
      
      
        <ul class="menu__sub-inner">
          <li class="menu__sub-inner-more-trigger">Show more ▾</li>

          <ul class="menu__sub-inner-more hidden">
            
              
                <li><a href="/crypto-in-ctf">Crypto in CTF</a></li>
              
            
          </ul>
        </ul>
      
    

    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/about-me">About Me</a></li>
      
    
      
        <li><a href="/blogroll">Blogroll</a></li>
      
    
      
        <li><a href="/crypto-in-ctf">Crypto in CTF</a></li>
      
    
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<div class="post">
  <h1 class="post-title">
    <a href="https://mystiz.hk/posts/2021/2021-04-08-angstromctf-2021/">ångstromCTF 2021: Cache Money</a></h1>
  <div class="post-meta">
    
      <span class="post-date">
        2021-04-08 
      </span>
    
    
    <span class="post-author">:: Mystiz</span>
    
  </div>

  
  <span class="post-tags">
    
    #<a href="https://mystiz.hk/tags/ctf/">ctf</a>&nbsp;
    
    #<a href="https://mystiz.hk/tags/angstromctf/">angstromctf</a>&nbsp;
    
    #<a href="https://mystiz.hk/tags/crypto/">crypto</a>&nbsp;
    
    #<a href="https://mystiz.hk/tags/web/">web</a>&nbsp;
    
    #<a href="https://mystiz.hk/tags/aes/">aes</a>&nbsp;
    
    #<a href="https://mystiz.hk/tags/timing-attack/">timing-attack</a>&nbsp;
    
  </span>
  

  

  
    <img src="https://mystiz.hk/images/2021-04-08-angstromctf/cache-money.png" class="post-cover center" alt="ångstromCTF 2021: Cache Money" />
  

  <div class="post-content js-toc-content"><div>
        <p>I played ångstromCTF 2021 for <a href="https://twitter.com/blackb6a" target="_blank" rel="nofollow">@blackb6a</a> to spend my Easter holiday. I solved most of the reverse and cryptography challenges alone. In particular, <em>Cache Money</em> is one of the harder crypto challenges that I spent more than one day dealing with. It is very rewarding, and eventually four teams ended up solving it.</p>

<h2 id="challenge-summary">Challenge Summary<a href="#challenge-summary" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>

<p>This challenge reimplements the Advanced Encryption Standard (AES) on 128, 192 and 256-bit keys. The encryptor is equipped with caches and we are given a service to encrypt (or decrypt) our messages. In short, there are four oracles provided by the service ($k_0$ is the fixed secret key and $b \in \{128, 192, 256\}$).</p>

<ul>
<li>$\mathcal{E}(m, k)$ encrypts a message $m$ with $k$,</li>
<li>$\mathcal{D}(c, k)$ decrypts a ciphertext $c$ with $k$,</li>
<li>$\mathcal{E}_0(m, b)$ encrypts a message $m$ with the first $b$ bits of $k_0$, are</li>
<li>$\mathcal{D}_0(c, b)$ decrypts a ciphertext $c$ with the first $b$ bits of $k_0$.</li>
</ul>

<p>Apart from the ciphertext (resp. plaintext), each oracle returns also the amount of time, in nanoseconds, used for encryption (resp. decryption).</p>

<p>Additionally, there is an flag $m_0$ encrypted with the $k_0$ under AES-256. The objective is of course decrypt and retrieve the flag. Needless to mention, they had measures to avoid the flag being retrieved by calling $\mathcal{D}_0(c_0, 256)$ directly. At least I am not awared of a way to solve this without recovering the key.</p>

<h2 id="solution">Solution<a href="#solution" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>

<h3 id="part-i-what-is-that-cache">Part I: What is that cache?<a href="#part-i-what-is-that-cache" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>

<h4 id="the-caching-strategy">The caching strategy<a href="#the-caching-strategy" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>

<p>From the challenge, there is a <code>Rijndael</code> class that encrypts and decrypts messages. All of the functions inside the class are decorated with <code>@instance_method_cache</code> and they will call the cache method defined below:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">instance_method_cache</span>(f):
    <span style="color:#75715e"># lru_cache uses the same cache for every instance which kinda sucks</span>
    <span style="color:#75715e"># so i made my own cache implementation</span>
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">wrapper</span>(self, <span style="color:#f92672">*</span>args):
        key <span style="color:#f92672">=</span> (f<span style="color:#f92672">.</span>__name__, <span style="color:#f92672">*</span>args)
        <span style="color:#66d9ef">try</span>:
            <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>cache[key][<span style="color:#ae81ff">0</span>]
        <span style="color:#66d9ef">except</span> <span style="color:#a6e22e">TypeError</span>:
            <span style="color:#75715e"># deal with unhashable arguments</span>
            <span style="color:#66d9ef">return</span> f(self, <span style="color:#f92672">*</span>args)
        <span style="color:#66d9ef">except</span> <span style="color:#a6e22e">KeyError</span>:
            <span style="color:#75715e"># remove the least recently used element</span>
            <span style="color:#75715e"># dont want the cache blowing up</span>
            <span style="color:#66d9ef">while</span> len(self<span style="color:#f92672">.</span>cache<span style="color:#f92672">.</span>keys()) <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">300</span>:
                mintimestamp <span style="color:#f92672">=</span> timestamp()
                keys <span style="color:#f92672">=</span> list(self<span style="color:#f92672">.</span>cache<span style="color:#f92672">.</span>keys())
                lowest <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
                <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(keys)):
                    <span style="color:#66d9ef">if</span> self<span style="color:#f92672">.</span>cache[keys[i]][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">&lt;</span> mintimestamp:
                        mintimestamp <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>cache[keys[i]][<span style="color:#ae81ff">1</span>]
                        lowest <span style="color:#f92672">=</span> i
                    <span style="color:#66d9ef">else</span>:
                        <span style="color:#66d9ef">continue</span>
                <span style="color:#66d9ef">del</span> self<span style="color:#f92672">.</span>cache[keys[lowest]]
            ret <span style="color:#f92672">=</span> f(self, <span style="color:#f92672">*</span>args)
            self<span style="color:#f92672">.</span>cache[key] <span style="color:#f92672">=</span> (ret, timestamp())
            <span style="color:#66d9ef">return</span> ret

    <span style="color:#66d9ef">return</span> wrapper</code></pre></div>
<p>Suppose we want to call $\mathcal{F}(x)$. This is how the caching works:</p>

<ol>
<li>If $(\mathcal{F}, x)$ is cached, <strong>return</strong> the cached value of $\mathcal{F}(x)$.</li>
<li>Drop the oldest entry from the cache until there are less than 300 entries.</li>
<li>Compute $y := \mathcal{F}(x)$, cache $y$ as the value to $(\mathcal{F}, x)$ and <strong>return</strong> it.</li>
</ol>

<h4 id="caching-in-action-encrypting-a-dummy-flag-with-a-dummy-key">Caching in action: Encrypting a dummy flag with a dummy key<a href="#caching-in-action-encrypting-a-dummy-flag-with-a-dummy-key" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>

<p>I added a hook to log the entries and see how the function calls are triggered:</p>
<pre tabindex="0"><code class="language-diff-python&nbsp;diff-highlight" data-lang="diff-python&nbsp;diff-highlight">-   self.cache[key] = (ret, timestamp())
+   t2 = timestamp()
+   val = (ret, t2)
+   self.cache[key] = val
+   print(f&#39;[+] self.cache[{key}] = {val} (time spent: {t2 - t1})&#39;)</code></pre>
<p>This is a <a href="https://gist.github.com/samueltangz/cbba3f529d07396d1a196ebf7693599f#file-angstromctf-2021-cache-money-sample-log">transcript</a> that encrypts <code>actf{this_is_a_test_flag}</code> with the key being <code>Tes3UeYGqoq6vatPmlM6uQrTA7OTLNP8</code>. There are two parts:</p>

<ol>
<li>(<em>Lines 1-369</em>) Initializes the <code>Rijndael</code> class with the key.</li>
<li>(<em>Lines 375-5690</em>) Encrypts the message.</li>
</ol>

<p>For the oracles, only second part will be timed.</p>

<h3 id="part-ii-obviously-a-timing-attack-but-how">Part II: Obviously a timing attack, but how?<a href="#part-ii-obviously-a-timing-attack-but-how" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>

<p>It takes around 0.7 seconds to encrypt a random block of message under AES-256. A costy operation would be <code>MixColumns</code> - it is called 13 times and each contributes ~6% to the total encryption time (hence around 85% in total). Unfortunately, it is not feasible to read cached <code>MixColumns</code> for the timing attack. Here's why:</p>

<div class="alert warning">
  <strong>Don&rsquo;t believe that 0.7s.</strong> The time is measured with there is verbose logging, and I/O definitely takes a considerable amount of time. It takes only 0.2s without logging (which is still pretty slow by the way).
</div>


<ol>
<li>Suppose that $m_1, m_2, ..., m_{13}$ are the inputs for <code>MixColumns</code>. It is not likely to find $m_i = m_j$ for some distinct pairs $(i, j)$.</li>
<li>The time fluctuates a lot and it is not reliable measuring a 6% difference.</li>
</ol>

<p>Well, I think timing attack is difficult solely with the second point. There are many function calls triggered by a single <code>encrypt_block</code>, including:</p>

<ul>
<li>~1.8K <code>Add</code> calls,

<ul>
<li>15 of them add two 4&times;4 matrices (~5ms each),</li>
<li>60 of them add two array of 4 entries (~1ms each),</li>
<li>the remainder adds two numbers (~0.2ms each).</li>
</ul></li>
<li>~380 <code>Multiply</code> calls (~1ms each),</li>
<li>~350 <code>Double</code> calls (~0.2ms each),</li>
<li>56 <code>SubWord</code> calls (~0.2ms each),</li>
<li>14 <code>ShiftRows</code> calls (~0.2ms each), and</li>
<li>13 <code>MixColumns</code> calls (~40ms each).</li>
</ul>

<p>That is a lot of uncertainty. It would be much better if we are able to determine whether a single <code>Add</code> operation is cached... Is it even possible?</p>

<p>I had no idea. The challenge author released a hint few hours later:</p>

<blockquote>
<p>Hint 1: This is also partially a web challenge...look for something you can exploit to make things more consistent.</p>
</blockquote>

<p>There must be something fishy being a <em>web</em> challenge. Let's look at the source code for the encryption endpoint:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#a6e22e">@instance_method_cache</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">encrypt</span>(self, m):
    <span style="color:#66d9ef">try</span>:
        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">.</span>join(
            self<span style="color:#f92672">.</span>encrypt_block(m[i:][:<span style="color:#ae81ff">16</span>]) <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, len(m), <span style="color:#ae81ff">16</span>)
        )
    <span style="color:#66d9ef">except</span>:
        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;Error&#34;</span>
        
<span style="color:#a6e22e">@app</span><span style="color:#f92672">.</span>route(<span style="color:#e6db74">&#34;/api/enc&#34;</span>, methods<span style="color:#f92672">=</span>[<span style="color:#e6db74">&#34;POST&#34;</span>])
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">encrypt</span>():
    m <span style="color:#f92672">=</span> tuple(request<span style="color:#f92672">.</span>json[<span style="color:#e6db74">&#34;a&#34;</span>])
    <span style="color:#75715e"># Does not pad if the length of message is a multiple of 16</span>
    <span style="color:#66d9ef">if</span> len(m) <span style="color:#f92672">%</span> <span style="color:#ae81ff">16</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>:
        m <span style="color:#f92672">=</span> m <span style="color:#f92672">+</span> (<span style="color:#ae81ff">0</span>,) <span style="color:#f92672">*</span> (<span style="color:#ae81ff">16</span> <span style="color:#f92672">-</span> (len(m) <span style="color:#f92672">%</span> <span style="color:#ae81ff">16</span>))
    <span style="color:#66d9ef">if</span> request<span style="color:#f92672">.</span>json[<span style="color:#e6db74">&#34;secret&#34;</span>] <span style="color:#f92672">not</span> <span style="color:#f92672">in</span> [<span style="color:#e6db74">&#34;secret128&#34;</span>, <span style="color:#e6db74">&#34;secret192&#34;</span>, <span style="color:#e6db74">&#34;secret256&#34;</span>]:
        k <span style="color:#f92672">=</span> tuple(request<span style="color:#f92672">.</span>json[<span style="color:#e6db74">&#34;k&#34;</span>])
    <span style="color:#66d9ef">else</span>:
        <span style="color:#75715e"># Takes the first n bytes of the secret if we are using k0 for encryption.</span>
        k <span style="color:#f92672">=</span> key[
            : {<span style="color:#e6db74">&#34;secret128&#34;</span>: <span style="color:#ae81ff">16</span>, <span style="color:#e6db74">&#34;secret192&#34;</span>: <span style="color:#ae81ff">24</span>, <span style="color:#e6db74">&#34;secret256&#34;</span>: <span style="color:#ae81ff">32</span>}[
                request<span style="color:#f92672">.</span>json[<span style="color:#e6db74">&#34;secret&#34;</span>]
            ]
        ]
    <span style="color:#66d9ef">try</span>:
        cipher <span style="color:#f92672">=</span> Rijndael(k)
    <span style="color:#66d9ef">except</span> <span style="color:#a6e22e">ValueError</span>:
        <span style="color:#66d9ef">return</span> jsonify({<span style="color:#e6db74">&#34;result&#34;</span>: <span style="color:#e6db74">&#34;Invalid key&#34;</span>, <span style="color:#e6db74">&#34;time&#34;</span>: <span style="color:#ae81ff">0</span>})
    start <span style="color:#f92672">=</span> timer()
    enc <span style="color:#f92672">=</span> cipher<span style="color:#f92672">.</span>encrypt(m)
    end <span style="color:#f92672">=</span> timer()
    <span style="color:#66d9ef">del</span> cipher
    <span style="color:#66d9ef">return</span> jsonify({<span style="color:#e6db74">&#34;result&#34;</span>: enc<span style="color:#f92672">.</span>hex(), <span style="color:#e6db74">&#34;time&#34;</span>: end <span style="color:#f92672">-</span> start})</code></pre></div>
<p>Note that if we are encrypting the message block <code>actf{this_is_a_t</code> with $k_0$ under AES-256, then this is the JSON object we send:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json"><span style="color:#75715e">// Request
</span><span style="color:#75715e"></span>{
    <span style="color:#f92672">&#34;a&#34;</span>: [<span style="color:#ae81ff">97</span>, <span style="color:#ae81ff">99</span>, <span style="color:#ae81ff">116</span>, <span style="color:#ae81ff">102</span>, <span style="color:#ae81ff">123</span>, <span style="color:#ae81ff">116</span>, <span style="color:#ae81ff">104</span>, <span style="color:#ae81ff">105</span>, <span style="color:#ae81ff">115</span>, <span style="color:#ae81ff">95</span>, <span style="color:#ae81ff">105</span>, <span style="color:#ae81ff">115</span>, <span style="color:#ae81ff">95</span>, <span style="color:#ae81ff">97</span>, <span style="color:#ae81ff">95</span>, <span style="color:#ae81ff">116</span>],
    <span style="color:#f92672">&#34;secret&#34;</span>: <span style="color:#e6db74">&#34;secret256&#34;</span>
}

<span style="color:#75715e">// Response
</span><span style="color:#75715e"></span>{
    <span style="color:#f92672">&#34;result&#34;</span>: <span style="color:#e6db74">&#34;83696d00a4e4def3a9ca1c3e61b899cb&#34;</span>,
    <span style="color:#f92672">&#34;time&#34;</span>: <span style="color:#ae81ff">144329411</span>
}</code></pre></div>
<p>What if we send a malformed <code>a</code>? The exception is raised in a lower level function and is handled by <code>encrypt(self, m)</code>. It is good to see the time measured.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{<span style="color:#f92672">&#34;a&#34;</span>: [[]], <span style="color:#f92672">&#34;secret&#34;</span>: <span style="color:#e6db74">&#34;secret256&#34;</span>} <span style="color:#75715e">// Request
</span><span style="color:#75715e"></span>{<span style="color:#f92672">&#34;result&#34;</span>: <span style="color:#e6db74">&#34;4572726f72&#34;</span>, <span style="color:#f92672">&#34;time&#34;</span>: <span style="color:#ae81ff">45599</span>} <span style="color:#960050;background-color:#1e0010">//</span> <span style="color:#960050;background-color:#1e0010">Response</span> <span style="color:#960050;background-color:#1e0010">(</span><span style="color:#e6db74">&#34;4572726f72&#34;</span> <span style="color:#960050;background-color:#1e0010">is</span> <span style="color:#960050;background-color:#1e0010">Error</span> <span style="color:#960050;background-color:#1e0010">hexed)</span></code></pre></div>
<p>Currently we are measuring <em>nothing</em>, since exception is raised before the first function call is completed. Let's throw after the first function call:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{<span style="color:#f92672">&#34;a&#34;</span>: [<span style="color:#ae81ff">1337</span>, []], <span style="color:#f92672">&#34;secret&#34;</span>: <span style="color:#e6db74">&#34;secret256&#34;</span>} <span style="color:#75715e">// Request
</span><span style="color:#75715e"></span>{<span style="color:#f92672">&#34;result&#34;</span>: <span style="color:#e6db74">&#34;4572726f72&#34;</span>, <span style="color:#f92672">&#34;time&#34;</span>: <span style="color:#ae81ff">189082</span>} <span style="color:#960050;background-color:#1e0010">//</span> <span style="color:#960050;background-color:#1e0010">Response</span></code></pre></div>
<p>By throwing errors in an early stage, the time differences are more significant than the fluctuations now. Nice!</p>

<h3 id="part-iii-leaking-one-eighth-of-the-key">Part III: Leaking one eighth of the key<a href="#part-iii-leaking-one-eighth-of-the-key" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>

<h4 id="a-drop-in-response-time">A drop in response time<a href="#a-drop-in-response-time" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>

<p>As mentioned above, the first 369 lines from my <a href="https://gist.github.com/samueltangz/cbba3f529d07396d1a196ebf7693599f#file-angstromctf-2021-cache-money-sample-log">transcript</a> is where the <code>Rijndael</code> instance being initialized. Lines 1-55 is the log for computing the round constants <code>rcon</code>. Lines 56-369 represents how the round keys are computed, and this is part of the transcript:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">56:[+] self.cache[(&#39;RotWord&#39;, (76, 78, 80, 56))] = ((78, 80, 56, 76), 505349375647612, 8617) (time spent: 8617)
57:[+] self.cache[(&#39;SubWord&#39;, (78, 80, 56, 76))] = ((47, 83, 7, 41), 505349375732640, 14356) (time spent: 14356)
58:[+] self.cache[(&#39;Add&#39;, 47, 1)] = (46, 505349375825251, 9545) (time spent: 9545)
59:[+] self.cache[(&#39;Add&#39;, 83, 0)] = (83, 505349375902264, 9931) (time spent: 9931)
60:[+] self.cache[(&#39;Add&#39;, 7, 0)] = (7, 505349375978725, 9218) (time spent: 9218)
61:[+] self.cache[(&#39;Add&#39;, 41, 0)] = (41, 505349376055553, 9776) (time spent: 9776)
62:[+] self.cache[(&#39;Add&#39;, (47, 83, 7, 41), (1, 0, 0, 0))] = ((46, 83, 7, 41), 505349376123267, 320106) (time spent: 320106)
63:[+] self.cache[(&#39;Add&#39;, 84, 46)] = (122, 505349376211788, 7671) (time spent: 7671)
64:[+] self.cache[(&#39;Add&#39;, 101, 83)] = (54, 505349376306808, 11562) (time spent: 11562)
65:[+] self.cache[(&#39;Add&#39;, 115, 7)] = (116, 505349376404211, 12700) (time spent: 12700)
66:[+] self.cache[(&#39;Add&#39;, 51, 41)] = (26, 505349376486636, 9646) (time spent: 9646)
67:[+] self.cache[(&#39;Add&#39;, (84, 101, 115, 51), (46, 83, 7, 41))] = ((122, 54, 116, 26), 505349376555581, 361347) (time spent: 361347)
68:[+] self.cache[(&#39;Add&#39;, 85, 122)] = (47, 505349376655242, 16317) (time spent: 16317)
69:[+] self.cache[(&#39;Add&#39;, 101, 54)] = (83, 505349376735919, 10524) (time spent: 10524)
   ...</code></pre></div>
<p>AES-128 and AES-192 have less than 300 function calls computing the round keys, thus every single step taken for round keys is cached. This is not the case for AES-256. Therefore, we should attempt to leak something from $k_0$ via $\mathcal{E}_0(m, 128)$ or $\mathcal{E}_0(m, 192)$. To achieve this, let's try to make use of the error-throwing strategy we discussed in the last part.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{<span style="color:#f92672">&#34;a&#34;</span>: [<span style="color:#ae81ff">1337</span>, []], <span style="color:#f92672">&#34;secret&#34;</span>: <span style="color:#e6db74">&#34;secret128&#34;</span>} <span style="color:#75715e">// Request
</span><span style="color:#75715e"></span>{<span style="color:#f92672">&#34;result&#34;</span>: <span style="color:#e6db74">&#34;4572726f72&#34;</span>, <span style="color:#f92672">&#34;time&#34;</span>: <span style="color:#ae81ff">159767</span>} <span style="color:#960050;background-color:#1e0010">//</span> <span style="color:#960050;background-color:#1e0010">Response</span></code></pre></div>
<p>Iterating <code>0 &lt;= a[0] &lt; 256</code>, it is observed the request <code>a[0] = 40</code> is particularly faster than the others.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{<span style="color:#f92672">&#34;a&#34;</span>: [<span style="color:#ae81ff">40</span>, []], <span style="color:#f92672">&#34;secret&#34;</span>: <span style="color:#e6db74">&#34;secret128&#34;</span>} <span style="color:#75715e">// Request
</span><span style="color:#75715e"></span>{<span style="color:#f92672">&#34;result&#34;</span>: <span style="color:#e6db74">&#34;4572726f72&#34;</span>, <span style="color:#f92672">&#34;time&#34;</span>: <span style="color:#ae81ff">40721</span>} <span style="color:#960050;background-color:#1e0010">//</span> <span style="color:#960050;background-color:#1e0010">Response</span></code></pre></div>
<h4 id="what-is-this-why-is-it-faster">What is this? Why is it faster?<a href="#what-is-this-why-is-it-faster" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>

<div class="alert danger">
  🤨 <strong>Confusion alert.</strong> I know it is getting more confusing. Please bear with me&hellip;
</div>


<p>In short, <code>Add(???, 40)</code> is cached... But what is that? To understand why, look at the constructor and the <code>encrypt_block</code> method:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">encrypt_block</span>(self, block):
    m <span style="color:#f92672">=</span> tuple(tuple(block[<span style="color:#ae81ff">4</span> <span style="color:#f92672">*</span> i :][:<span style="color:#ae81ff">4</span>]) <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">4</span>))
    m <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>Add(self<span style="color:#f92672">.</span>roundkeys[:<span style="color:#ae81ff">4</span>], m)
    <span style="color:#75715e"># ... omitted ...</span></code></pre></div>
<p>This is how the methods called during <code>encrypt_block</code>, in order:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">encrypt_block(block)
-&gt;  [...  Computes m &lt;- block  ...]
-&gt;  Add(roundkeys[:4], m)
    -&gt;  Add(roundkeys[0], m[0])
        -&gt;  Add(roundkeys[0][0], m[0][0]) [... 💰 Uses the cache ...]
        -&gt;  Add(roundkeys[0][1], m[0][1]) [... 🔥 Throws an error ... ]

            [... The subsequent functions are not called ...]

        -&gt;  Add(roundkeys[0][2], m[0][2])
        -&gt;  Add(roundkeys[0][3], m[0][3])
    -&gt;  Add(roundkeys[1], m[1])
    -&gt;  ...</code></pre></div>
<p>Therefore, that <code>Add(???, 40)</code> cached is actually <code>Add(roundkeys[0][0], m[0][0])</code>. With the same strategy, we can find <code>a[1]</code>, <code>a[2]</code> and <code>a[3]</code> that the API calls has a smaller response time: <code>67, 82, 56</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{<span style="color:#f92672">&#34;a&#34;</span>: [<span style="color:#ae81ff">40</span>, <span style="color:#ae81ff">67</span>, <span style="color:#ae81ff">82</span>, <span style="color:#ae81ff">56</span>, []], <span style="color:#f92672">&#34;secret&#34;</span>: <span style="color:#e6db74">&#34;secret128&#34;</span>} <span style="color:#75715e">// Request
</span><span style="color:#75715e"></span>{<span style="color:#f92672">&#34;result&#34;</span>: <span style="color:#e6db74">&#34;4572726f72&#34;</span>, <span style="color:#f92672">&#34;time&#34;</span>: <span style="color:#ae81ff">40665</span>} <span style="color:#960050;background-color:#1e0010">//</span> <span style="color:#960050;background-color:#1e0010">Response</span></code></pre></div>
<p>What does <code>(40, 67, 82, 56)</code> mean? From the cache's perspective, the function call <code>Add(roundkeys[0], (40, 67, 82, 56))</code> is cached. But why is it cached? Looking back at the constructor, this is executed when the round keys are computed:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">Add(w[<span style="color:#ae81ff">0</span>], Add(SubWord(RotWord(w[<span style="color:#ae81ff">3</span>])), rcon[<span style="color:#ae81ff">1</span>]))</code></pre></div>
<p>Hereby <code>w[0]</code> and <code>w[3]</code> are respectively <code>roundkeys[0]</code> and <code>roundkeys[3]</code>, while <code>rcon[1] == (1, 0, 0, 0)</code>. That said, it is very likely that <code>(40, 67, 82, 56)</code> is being the second argument, i.e.:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">Add(SubWord(RotWord(roundkeys[<span style="color:#ae81ff">3</span>])), rcon[<span style="color:#ae81ff">1</span>]) <span style="color:#f92672">==</span> (<span style="color:#ae81ff">40</span>, <span style="color:#ae81ff">67</span>, <span style="color:#ae81ff">82</span>, <span style="color:#ae81ff">56</span>)

<span style="color:#75715e"># eqivalently...</span>

sbox(roundkeys[<span style="color:#ae81ff">3</span>][<span style="color:#ae81ff">1</span>]) <span style="color:#f92672">^</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">40</span>
sbox(roundkeys[<span style="color:#ae81ff">3</span>][<span style="color:#ae81ff">2</span>])     <span style="color:#f92672">==</span> <span style="color:#ae81ff">67</span>
sbox(roundkeys[<span style="color:#ae81ff">3</span>][<span style="color:#ae81ff">3</span>])     <span style="color:#f92672">==</span> <span style="color:#ae81ff">82</span>
sbox(roundkeys[<span style="color:#ae81ff">3</span>][<span style="color:#ae81ff">0</span>])     <span style="color:#f92672">==</span> <span style="color:#ae81ff">56</span>

<span style="color:#75715e"># and equivalently...</span>

roundkeys[<span style="color:#ae81ff">3</span>][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span>  <span style="color:#ae81ff">76</span>
roundkeys[<span style="color:#ae81ff">3</span>][<span style="color:#ae81ff">2</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">100</span>
roundkeys[<span style="color:#ae81ff">3</span>][<span style="color:#ae81ff">3</span>] <span style="color:#f92672">==</span>  <span style="color:#ae81ff">72</span>
roundkeys[<span style="color:#ae81ff">3</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">118</span></code></pre></div>
<p>On top of that, <code>roundkeys[3] == key[12:16]</code>. Therefore we have recovered four bytes of $k_0$. We can further recover the first eight bytes of $k_0$ by testing <code>a[4]</code>, <code>a[5]</code>, ..., <code>a[11]</code>. Since we have 12 bytes of the key, we can exhaust to recover the secret key used for AES-128 (i.e., <code>key[0:16]</code>)</p>

<p>The idea can be used when dealing with AES-192. We are able to recover <code>key[20:24]</code> by finding an appropriate input for <code>a[0]</code>, <code>a[1]</code>, <code>a[2]</code> and <code>a[3]</code>, and eventually <code>key[0:24]</code> by brute-forcing the remaining bytes.</p>

<h3 id="part-iv-the-cache-is-not-in-reach-for-aes256">Part IV: The cache is not in reach for AES-256!<a href="#part-iv-the-cache-is-not-in-reach-for-aes256" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>

<p>Unfortunately, we cannot generalize the idea to recover keys under AES-256 because there are more than 300 function calls for computing round keys. Hence, the cache for <code>Add(roundkeys[0][0], m[0][0])</code> and others have already expired prior than they are used. Only the round keys for the later rounds are cached. With that said, we can use $\mathcal{D}_0(c, 256)$ instead of $\mathcal{E}_0(m, 256)$ and recover the round keys generated near-end. Specifically they are <code>roundkeys[49] == a[0:4]</code>, <code>roundkeys[50] == a[4:8]</code> and <code>roundkeys[51] == a[8:12]</code>.</p>

<div class="alert info">
  <strong>Why?</strong> The proof is left as readers' exercise (I apologize being lazy and I have actually lose patient spending five hours compiling this writeup during CTF).
</div>


<p>Since we have <code>roundkeys[0]</code>, <code>roundkeys[1]</code>, ..., <code>roundkeys[5]</code>, we can retrieve <code>key[24:32]</code> using <em>Z3</em>. Eventually we found <code>key == b'fGsOY9Xb4Eq5vLdHzDGbJ4QvQqOCQcYm'</code> and could decrypt the flag: <code>actf{if_you_cache_my_drift}</code>. First 🩸!</p>

<div class="alert success">
  🔑 <strong>Solution script!</strong> The full solution script is available <a href="https://gist.github.com/samueltangz/cbba3f529d07396d1a196ebf7693599f#file-angstromctf-2021-cache-money-solve-py">here</a> (and <a href="https://gist.github.com/samueltangz/cbba3f529d07396d1a196ebf7693599f#file-angstromctf-2021-cache-money-solve-log">its output</a>). Hope this explains how my attack works.
</div>


<h3 id="part-v-attacks-without-timereading">Part V: Attacks without time-reading<a href="#part-v-attacks-without-timereading" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>

<div class="alert warning">
  <strong>Note.</strong> This is not my idea. I found this pretty mind-blowing so I shamelessly document this as well. Kudos to <em>UnblvR</em>!
</div>


<p>In short, one can send a float to determine if an item is cached. One could check if <code>Add(roundkeys[0][0], 1337)</code> is cached by sending the below JSON object:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{<span style="color:#f92672">&#34;a&#34;</span>: [<span style="color:#ae81ff">1337.0</span>] <span style="color:#e6db74">&#34;secret&#34;</span>: <span style="color:#e6db74">&#34;secret128&#34;</span>} <span style="color:#960050;background-color:#1e0010">//</span> <span style="color:#960050;background-color:#1e0010">Request</span></code></pre></div>
<p>It happens that an error is thrown if and only if <code>Add(roundkeys[0][0], 1337)</code> is not cached. The cached output will be returned if <code>Add(roundkeys[0][0], 1337)</code> is cached, since <code>(&quot;Add&quot;, roundkeys[0][0], 1337) == (&quot;Add&quot;, roundkeys[0][0], 1337.0)</code>. However, on the other hand, it will attempt to compute <code>roundkeys[0][0] ^ 1337.0</code>. This throws an error since xorring an integer with a float is not a defined behaviour.</p>

      </div></div>

  
  
<div class="pagination">
    <div class="pagination__title">
        <span class="pagination__title-h">Read other posts</span>
        <hr />
    </div>
    <div class="pagination__buttons">
        
        <span class="button previous">
            <a href="https://mystiz.hk/posts/2021/2021-04-19-plaidctf-leaky-block-cipher/">
                <span class="button__icon">←</span>
                <span class="button__text">PlaidCTF 2021: Leaky Block Cipher</span>
            </a>
        </span>
        
        
        <span class="button next">
            <a href="https://mystiz.hk/posts/2021/2021-04-01-binary-exploitation-1/">
                <span class="button__text">My Path of Binary Exploitation (1)</span>
                <span class="button__icon">→</span>
            </a>
        </span>
        
    </div>
</div>

  

  

</div>


<aside class="toc-container">
  <a href="#" style="text-decoration: none; font-weight: 700;">
    ångstromCTF 2021: Cache Money
  </a>
  <div class="js-toc"></div>
</aside>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.12.0/tocbot.min.css" integrity="sha512-SFw7k74K3983tyOlJIHa8atr9Ppef3Kix5cmifwzU7ZdtU2E0FRuOVRtd3ENpMJ8sNCie5hlb/0j23efcdQJXA==" crossorigin="anonymous" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.12.0/tocbot.min.js" integrity="sha512-oD3xGN8YTxenx6tdS4D/RKqO4OtORBQtAb2/FseM17GGMIi6jMwKUBc8duX4A5RwMOGGXoFBZrsqbOk8GpXFgQ==" crossorigin="anonymous"></script>

<script type="text/javascript">
  tocbot.init({
      headingSelector: 'h1, h2, h3, h4',
      orderedList: false,
      headingLabelCallback: s => s.substr(0, s.length-2),
      collapseDepth: 2
  });
</script>



  </div>
  <aside class="ads">
    
  
  <ins class="adsbygoogle"
    style="display:block"
    data-ad-client="ca-pub-3220069814773012"
    data-ad-slot="6927401005"
    data-ad-format="auto"
    data-full-width-responsive="true"></ins>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
  </script>


  </aside>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>© 2023 Powered by <a href="http://gohugo.io">Hugo</a></span>
    
        <span>:: Theme made by <a href="https://twitter.com/panr">panr</a></span>
      </div>
  </div>
</footer>

<script src="https://mystiz.hk/assets/main.js"></script>
<script src="https://mystiz.hk/assets/prism.js"></script>






<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"
  integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js"
  integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js"
  integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"
  onload="renderMathInElement(document.body, { delimiters: [{ left: '$$', right: '$$', display: true }, { left: '\\[', right: '\\]', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }], trust: true })"></script>
<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/viz.js/2.1.2/viz.js"></script>
<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/viz.js/2.1.2/full.render.js"></script>
<script>
var viz = new Viz();

document.querySelectorAll("[class=graphviz]").forEach(node => {
  const escape = function (s) {
    const t = s.replace(/&amp;/g, '&')
    return t.replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&#34;/g, '"')
  }
  viz.renderSVGElement(escape(node.innerText), {
    engine: 'dot'
  }).then(function (element) {
    node.parentNode.appendChild(element)
    node.style.display = 'none'
  })
})
</script>
<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<script>
mermaid.initialize({
    startOnLoad: true,
    htmlLabels: true,
    securityLevel: "loose",
    theme: 'base',
    themeVariables: {
        background: '#22222c',
        primaryColor: '#33333c',
        primaryTextColor: '#ffe4e1',
    }
});
</script>

  
<script async src="https://www.googletagmanager.com/gtag/js?id=G-2VLBDVW913"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-2VLBDVW913');
</script>



  
</div>

</body>
</html>
